<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Mota-Desk v4.0</title>
  <style>
    :root {
      --bg: #0a0e27;
      --panel: #141829;
      --panel-light: #1a2035;
      --text: #e8eaed;
      --text-secondary: #9ca3af;
      --accent: #10b981;
      --accent-hover: #34d399;
      --danger: #ef4444;
      --warn: #f59e0b;
      --border: #1f2937;
      --border-light: #2d3748;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0; height: 100%; background: var(--bg); color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body { display: flex; flex-direction: column; }

    /* Header */
    .header {
      background: linear-gradient(135deg, #141829 0%, #0f1419 100%);
      padding: 12px 20px; border-bottom: 1px solid var(--border);
      display: flex; align-items: center; justify-content: space-between;
    }
    .header h1 { margin: 0; font-size: 16px; font-weight: 700; color: var(--accent); letter-spacing: 0.5px; }
    .status-badge { 
      padding: 4px 12px; background: rgba(16, 185, 129, 0.1); color: var(--accent); 
      border-radius: 4px; font-weight: 600; font-size: 12px; border: 1px solid rgba(16, 185, 129, 0.3);
    }

    /* Toolbar */
    .toolbar {
      display: flex; gap: 10px; align-items: center; padding: 10px 20px;
      background: var(--panel); border-bottom: 1px solid var(--border);
    }
    button {
      background: var(--accent); color: #000; border: 0; border-radius: 4px; padding: 8px 16px;
      font-weight: 600; cursor: pointer; font-size: 12px; transition: all 0.2s;
    }
    button:hover { background: var(--accent-hover); transform: translateY(-1px); }
    button.secondary { background: var(--panel); color: var(--text); border: 1px solid var(--border); }
    button.secondary:hover { background: var(--border-light); }
    
    /* SMS Button specific styles */
    .btn.primary { background: var(--accent); color: #000; }
    .btn {
      padding: 6px 12px; border-radius: 4px; border: 1px solid transparent;
      cursor: pointer; font-size: 12px; font-weight: 600; transition: 0.2s;
    }

    /* Main container */
    main { flex: 1; overflow: hidden; display: flex; gap: 16px; padding: 16px; }

    /* LEFT PANEL: Queue */
    .queue-panel {
      display: flex; flex-direction: column; overflow: hidden;
      background: var(--panel); border-radius: 8px; border: 1px solid var(--border);
      width: 320px; flex: 0 0 320px; min-width: 240px;
    }
    .queue-header {
      padding: 12px 16px; background: rgba(0, 0, 0, 0.3);
      color: var(--accent); font-weight: 700; font-size: 12px;
      text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid var(--border);
      display: flex; justify-content: space-between; align-items: center;
    }
    .queue-list { flex: 1; overflow-y: auto; }
    .queue-item {
      padding: 12px 16px; border-bottom: 1px solid var(--border-light);
      cursor: pointer; transition: all 0.15s; font-size: 13px;
    }
    .queue-item:hover { background: rgba(16, 185, 129, 0.05); }
    .queue-item.selected {
      background: rgba(16, 185, 129, 0.15); border-left: 3px solid var(--accent);
      padding-left: 13px;
    }
    .queue-name { font-weight: 700; color: var(--accent); margin-bottom: 4px; }
    .queue-meta { color: var(--text-secondary); font-size: 11px; display: flex; gap: 8px; }

    /* RIGHT PANEL: Customer detail */
    .detail-panel {
      display: flex; flex-direction: column; gap: 16px; overflow: hidden; flex: 1;
    }

    /* Header Card */
    .header-card {
      background: var(--panel); border: 1px solid var(--border); border-radius: 8px;
      padding: 16px 20px; display: grid; grid-template-columns: 1fr auto auto auto auto; 
      gap: 30px; align-items: center;
    }
    .customer-info { display: flex; flex-direction: column; }
    .customer-name { font-weight: 700; color: var(--text); font-size: 18px; margin-bottom: 4px; }
    .customer-meta { color: var(--text-secondary); font-size: 12px; display: flex; gap: 10px; align-items: center; }
    .vip-tag { color: var(--accent); font-weight: 700; background: rgba(16, 185, 129, 0.1); padding: 2px 6px; border-radius: 4px; }
    
    .stat-inline { display: flex; flex-direction: column; align-items: center; gap: 4px; }
    .stat-label { color: var(--text-secondary); font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; }
    .stat-value { color: var(--accent); font-weight: 700; font-size: 18px; }

    /* Content Grid - Resizable flex layout */
    .content-grid {
      display: flex; gap: 16px; flex: 1; overflow: hidden;
    }

    /* Columns */
    .col-left { display: flex; flex-direction: column; gap: 16px; overflow: hidden; width: 30%; min-width: 200px; }
    .col-center { display: flex; flex-direction: column; gap: 16px; overflow: hidden; width: 40%; min-width: 300px; }
    .col-right { display: flex; flex-direction: column; gap: 16px; overflow: hidden; width: 30%; min-width: 250px; }

    /* Resize Controls */
    .resize-controls { display: flex; gap: 2px; }
    .resize-btn { 
      background: transparent; border: 0; color: var(--text-secondary); 
      padding: 0 4px; cursor: pointer; font-size: 10px; opacity: 0.5; 
    }
    .resize-btn:hover { opacity: 1; color: var(--accent); }
    .panel-title-resizable { display: flex; justify-content: space-between; align-items: center; }

    /* Section Card */
    .card {
      background: var(--panel); border: 1px solid var(--border); border-radius: 8px;
      display: flex; flex-direction: column; overflow: hidden; flex: 1;
    }
    .card-header {
      padding: 12px 16px; background: rgba(0, 0, 0, 0.2);
      border-bottom: 1px solid var(--border); font-weight: 700; font-size: 12px;
      color: var(--accent); text-transform: uppercase; letter-spacing: 0.5px;
    }
    .card-content { flex: 1; overflow-y: auto; padding: 16px; font-size: 13px; }

    /* SMS Messenger Styles */
    .msg-bubble {
      max-width: 85%; padding: 8px 12px; border-radius: 12px;
      font-size: 12px; line-height: 1.4; position: relative; word-wrap: break-word;
      margin-bottom: 8px;
    }
    .msg-bubble.inbound {
      background: #2d3748; color: #e2e8f0; align-self: flex-start;
      border-bottom-left-radius: 2px;
    }
    .msg-bubble.outbound {
      background: var(--accent); color: #000; align-self: flex-end;
      border-bottom-right-radius: 2px;
    }
    .bubble-time {
      font-size: 9px; margin-top: 4px; opacity: 0.7; text-align: right;
    }
    .bubble-status {
      font-size: 8px; font-weight: 700; margin-left: 4px; opacity: 0.8;
    }

    /* Data Rows */
    .data-row { display: flex; justify-content: space-between; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid var(--border-light); }
    .data-row:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
    .data-label { color: var(--text-secondary); }
    .data-value { color: var(--text); font-weight: 600; }

    /* Chart */
    .chart-container { display: flex; flex-direction: column; gap: 6px; }
    .chart-row { display: grid; grid-template-columns: 40px 1fr 30px; gap: 12px; align-items: center; font-size: 11px; }
    .chart-month { color: var(--text-secondary); font-weight: 600; }
    .chart-bar-bg { background: rgba(255,255,255,0.05); height: 6px; border-radius: 3px; overflow: hidden; }
    .chart-bar { height: 100%; background: var(--accent); border-radius: 3px; }
    .chart-count { color: var(--text); font-weight: 700; text-align: right; }
    
    /* Red Pulse Animation for Update */
    @keyframes pulse-red {
      0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); background-color: #ef4444; color: white; border-color: #ef4444; }
      70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); background-color: #ef4444; color: white; border-color: #ef4444; }
      100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); background-color: #ef4444; color: white; border-color: #ef4444; }
    }
    .pulse-red {
      animation: pulse-red 2s infinite;
    }

    /* Items List */
    .item-row { margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid var(--border-light); display: flex; gap: 8px; }
    .item-row:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
    .item-rank { color: var(--text-secondary); font-weight: 600; min-width: 20px; }
    .item-name { color: var(--text); flex: 1; }
    .item-count { color: var(--accent); font-weight: 700; }

    /* Visits Table */
    .visits-table { width: 100%; border-collapse: collapse; font-size: 12px; }
    .visits-table th { text-align: left; color: var(--text-secondary); font-weight: 600; padding: 8px; border-bottom: 1px solid var(--border); font-size: 11px; text-transform: uppercase; }
    .visits-table td { padding: 10px 8px; border-bottom: 1px solid var(--border-light); color: var(--text); vertical-align: top; }
    .visits-table tr:last-child td { border-bottom: none; }
    .visit-date { color: var(--accent); font-weight: 600; white-space: nowrap; }
    .visit-items { color: var(--text-secondary); font-size: 11px; line-height: 1.4; }
    .visit-budtender { color: var(--text); font-weight: 600; white-space: nowrap; }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border-light); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--border); }
    /* Animations */
    @keyframes pulse-red {
      0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); border-color: rgba(239, 68, 68, 0.7); color: #ef4444; }
      70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); border-color: rgba(239, 68, 68, 0); color: #ef4444; }
      100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); border-color: rgba(239, 68, 68, 0); color: #ef4444; }
    }
    .update-available {
      animation: pulse-red 2s infinite;
      border-color: #ef4444 !important;
      color: #ef4444 !important;
      font-weight: bold;
    }
    
    /* Tab System */
    .tab-btn {
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.2s;
      border: 1px solid transparent;
    }
    .tab-btn.active {
      background: var(--accent) !important;
      color: #000 !important;
    }
    
    /* View Containers */
    .view-container {
      display: none;
      flex: 1;
      overflow: hidden;
    }
    .view-container.active {
      display: flex !important;
    }
    
    /* Messages Table */
    #allMessagesList tr {
      transition: background 0.2s;
      cursor: pointer;
    }
    #allMessagesList tr:hover {
      background: rgba(16, 185, 129, 0.08);
    }
    
    /* Conversation Bubbles */
    .message-bubble {
      padding: 10px 14px;
      border-radius: 12px;
      max-width: 75%;
      word-wrap: break-word;
      font-size: 13px;
      line-height: 1.4;
    }
    .message-bubble.inbound {
      background: var(--panel-light);
      border: 1px solid var(--border);
      align-self: flex-start;
    }
    .message-bubble.outbound {
      background: var(--accent);
      color: #000;
      align-self: flex-end;
      margin-left: auto;
    }
    .message-time {
      font-size: 10px;
      color: var(--text-secondary);
      margin-top: 4px;
    }
    
    /* Pinned Items */
    .queue-item.pinned {
      background: rgba(16, 185, 129, 0.1);
      border-left: 3px solid var(--accent);
    }
    .pin-icon {
      opacity: 0.3;
      transition: opacity 0.2s;
    }
    .pin-icon:hover {
      opacity: 1;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <div class="header">
    <h1>Mota-Desk v4.0</h1>
    <div style="display: flex; gap: 12px; align-items: center;">
      <span class="status-badge" id="pollStatus">Initializing...</span>
    </div>
  </div>

  <div class="toolbar">
    <button id="tabDashboard" class="tab-btn active" onclick="switchView('dashboard')" style="background: var(--accent); color: #000;">üìä Dashboard</button>
    <button id="tabMessages" class="tab-btn" onclick="switchView('messages')" style="background: var(--panel); color: var(--text); border: 1px solid var(--border);">üí¨ All Messages</button>
    <div style="flex: 1;"></div>
    <button id="syncBtn" onclick="startSync()">üîÑ Sync Now</button>
    <button id="stopBtn" class="secondary" onclick="stopSync()">Stop</button>
    <button id="updateBtn" class="secondary" onclick="triggerUpdate()" title="Fetch latest version">‚¨á Update System</button>
    <button id="chatBtn" class="secondary" onclick="openChatModal()" style="background: #4a5568; border-color: #718096; color: white;">üí¨ Team Chat</button>
  </div>

  <main>
    <!-- DASHBOARD VIEW -->
    <div class="view-container active" id="viewDashboard" style="display: flex; flex-direction: row; gap: 16px; padding: 16px;">
    <!-- LEFT: Queue -->
    <div class="queue-panel" id="queuePanel">
      <div class="queue-header panel-title-resizable">
        <span>üéØ Queue</span>
        <div class="resize-controls">
          <button class="resize-btn" onclick="resizeColumn('queuePanel', -20)">‚óÄ</button>
          <button class="resize-btn" onclick="resizeColumn('queuePanel', 20)">‚ñ∂</button>
        </div>
      </div>
      <div class="queue-list" id="queueList"></div>
    </div>

    <!-- RIGHT: Customer Detail -->
    <div class="detail-panel">
      <!-- Header Card -->
      <div class="header-card" id="headerCard">
        <div class="customer-info">
          <div class="customer-name">Select Customer</div>
          <div class="customer-meta">‚Äî</div>
        </div>
        <div class="stat-inline">
          <div class="stat-label">Lifetime</div>
          <div class="stat-value" id="stat-lifetime">$0</div>
        </div>
        <div class="stat-inline">
          <div class="stat-label">Visits</div>
          <div class="stat-value" id="stat-visits">0</div>
        </div>
        <div class="stat-inline">
          <div class="stat-label">Avg Spend</div>
          <div class="stat-value" id="stat-avg">$0</div>
        </div>
        <div class="stat-inline">
          <div class="stat-label">Last Visit</div>
          <div class="stat-value" id="stat-last">‚Äî</div>
        </div>
      </div>

      <!-- Content Grid -->
      <div class="content-grid">
        <!-- LEFT COLUMN: Categories & Top Items -->
        <div class="col-left" id="colLeft">
          <!-- Categories & Brands -->
          <div class="card" style="flex: 0 0 auto; max-height: 50%;">
            <div class="card-header panel-title-resizable">
              <span>üìä Categories & Brands</span>
              <div class="resize-controls">
                <button class="resize-btn" onclick="resizeColumn('colLeft', -20)">‚óÄ</button>
                <button class="resize-btn" onclick="resizeColumn('colLeft', 20)">‚ñ∂</button>
              </div>
            </div>
            <div class="card-content">
              <div style="margin-bottom: 16px;">
                <div style="font-size: 11px; font-weight: 700; color: var(--accent); margin-bottom: 8px; text-transform: uppercase;">Top Categories</div>
                <div id="categoriesContent"></div>
              </div>
              <div>
                <div style="font-size: 11px; font-weight: 700; color: var(--accent); margin-bottom: 8px; text-transform: uppercase;">Top Brands</div>
                <div id="brandsContent"></div>
              </div>
            </div>
          </div>

          <!-- Top Items -->
          <div class="card">
            <div class="card-header">üõçÔ∏è Top 7 Items</div>
            <div class="card-content" id="itemsContent"></div>
          </div>
        </div>

        <!-- CENTER COLUMN: Analytics & Visits -->
        <div class="col-center" id="colCenter">
          <!-- Visit Pattern -->
          <div class="card" style="flex: 0 0 auto; max-height: 40%;">
            <div class="card-header panel-title-resizable">
              <span>üìà Visit Pattern (12 Months)</span>
              <div class="resize-controls">
                <button class="resize-btn" onclick="resizeColumn('colCenter', -20)">‚óÄ</button>
                <button class="resize-btn" onclick="resizeColumn('colCenter', 20)">‚ñ∂</button>
              </div>
            </div>
            <div class="card-content" id="analyticsContent"></div>
          </div>

          <!-- Last Visits -->
          <div class="card">
            <div class="card-header">üïê Last 5 Visits</div>
            <div class="card-content" style="padding: 0;">
              <table class="visits-table">
                <thead>
                  <tr>
                    <th style="width: 80px;">Date</th>
                    <th>Items</th>
                    <th style="width: 100px; text-align: right;">Budtender</th>
                  </tr>
                </thead>
                <tbody id="visitsContent"></tbody>
              </table>
            </div>
          </div>
        </div>

        <!-- RIGHT COLUMN: SMS Messenger -->
        <div class="col-right" id="colRight">
          
          <!-- HERO'S JOURNEY -->
          <div class="card" style="margin-bottom: 16px; flex: 0 0 auto;">
            <div class="card-header panel-title-resizable">
              <span>üó∫Ô∏è Hero's Journey</span>
            </div>
            <div class="card-content" id="journeyContent" style="padding: 12px;">
              <div class="muted" style="text-align: center;">Loading journey...</div>
            </div>
          </div>

          <!-- SMS MESSENGER -->
          <div class="card">
            <div class="card-header panel-title-resizable">
              <div style="display: flex; justify-content: space-between; align-items: center; flex: 1; margin-right: 10px;">
                <span>üí¨ SMS History</span>
                <span id="smsStatus" style="font-size: 10px; color: var(--text-secondary);"></span>
              </div>
              <div class="resize-controls">
                <button class="resize-btn" onclick="resizeColumn('colRight', -20)">‚óÄ</button>
                <button class="resize-btn" onclick="resizeColumn('colRight', 20)">‚ñ∂</button>
              </div>
            </div>
            <!-- SMS Thread -->
            <div id="smsThread" class="card-content" style="background: var(--bg); display: flex; flex-direction: column; gap: 8px;">
              <div class="muted" style="text-align: center; padding: 20px;">Select a customer</div>
            </div>
            <!-- Reply Box -->
            <div style="padding: 10px; border-top: 1px solid var(--border); background: var(--panel);">
              <div style="display: flex; gap: 8px; align-items: flex-start;">
                <textarea id="smsReplyText" placeholder="Type message..." style="flex: 1; min-height: 40px; max-height: 80px; padding: 8px; font-size: 11px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text); resize: vertical;"></textarea>
                <button class="btn primary" id="smsSendBtn" style="padding: 8px 12px;" onclick="sendSmsReply()">Send</button>
              </div>
              <div style="text-align: right; margin-top: 4px;">
                <span id="smsCharCount" style="color: var(--text-secondary); font-size: 9px;">0 / 160</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    </div>
    <!-- END DASHBOARD VIEW -->

    <!-- MESSAGES VIEW -->
    <div class="view-container" id="viewMessages" style="display: none; flex-direction: row; gap: 16px; padding: 16px;">
      <!-- LEFT: Messages List -->
      <div class="card" style="flex: 1; display: flex; flex-direction: column; overflow: hidden; min-width: 400px;">
        <div class="card-header">
          <span>üí¨ All Messages (Last 100)</span>
        </div>
        <div class="card-content" style="padding: 0; overflow-y: auto; flex: 1;">
          <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
            <thead style="background: rgba(0,0,0,0.3); position: sticky; top: 0; z-index: 10;">
              <tr>
                <th style="padding: 12px 16px; text-align: left; border-bottom: 1px solid var(--border); color: var(--accent); font-weight: 700; width: 140px;">Time</th>
                <th style="padding: 12px 16px; text-align: left; border-bottom: 1px solid var(--border); color: var(--accent); font-weight: 700; width: 80px;">Direction</th>
                <th style="padding: 12px 16px; text-align: left; border-bottom: 1px solid var(--border); color: var(--accent); font-weight: 700; width: 180px;">Phone / Customer</th>
                <th style="padding: 12px 16px; text-align: left; border-bottom: 1px solid var(--border); color: var(--accent); font-weight: 700; width: 100px;">Status</th>
                <th style="padding: 12px 16px; text-align: left; border-bottom: 1px solid var(--border); color: var(--accent); font-weight: 700;">Message</th>
              </tr>
            </thead>
            <tbody id="allMessagesList">
              <tr>
                <td colspan="5" style="padding: 40px; text-align: center; color: var(--text-secondary);">Loading messages...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      
      <!-- RIGHT: Conversation View -->
      <div class="card" style="flex: 1; display: flex; flex-direction: column; overflow: hidden; min-width: 400px;">
        <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
          <span id="conversationHeader">üí¨ Conversation</span>
          <button id="conversationPinBtn" 
                  onclick="pinConversationCustomer()"
                  style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary); padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; opacity: 0.3;"
                  title="Pin customer to queue">
            üìå Pin
          </button>
        </div>
        <div id="conversationView" class="card-content" style="flex: 1; overflow-y: auto; padding: 16px; display: flex; flex-direction: column; gap: 12px;">
          <div class="muted" style="text-align: center; padding: 40px;">Click a message to view conversation</div>
        </div>
        <div style="padding: 10px; border-top: 1px solid var(--border); background: var(--panel);">
          <div style="display: flex; gap: 8px; align-items: flex-start;">
            <textarea id="conversationReplyText" placeholder="Type message..." style="flex: 1; min-height: 60px; max-height: 120px; padding: 8px; font-size: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text); resize: vertical;"></textarea>
            <button class="btn primary" onclick="sendConversationReply()" style="padding: 8px 16px;">Send</button>
          </div>
          <div style="text-align: right; margin-top: 4px;">
            <span id="conversationCharCount" style="color: var(--text-secondary); font-size: 10px;">0 / 160</span>
          </div>
        </div>
      </div>
    </div>
    <!-- END MESSAGES VIEW -->
  </main>

  <div id="chatModal" style="display: none; position: fixed; top: 0; right: 0; bottom: 0; width: 400px; background: var(--panel); z-index: 2000; border-left: 1px solid var(--border); box-shadow: -5px 0 25px rgba(0,0,0,0.5); flex-direction: column;">
    <div style="padding: 15px; background: #1a202c; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
      <h3 style="margin: 0; color: var(--accent);">üí¨ Team Chat</h3>
      <button onclick="closeChatModal()" style="background: transparent; border: none; color: var(--text-secondary); font-size: 18px; cursor: pointer;">&times;</button>
    </div>
    
    <div id="chatMessages" style="flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px;">
      <div class="muted" style="text-align: center;">Loading history...</div>
    </div>

    <div style="padding: 15px; background: #1a202c; border-top: 1px solid var(--border);">
      <div style="margin-bottom: 10px;">
        <select id="chatIdentity" style="width: 100%; padding: 8px; background: var(--bg); border: 1px solid var(--border); color: var(--text); border-radius: 4px; font-size: 12px;">
          <option value="">Select Identity...</option>
        </select>
      </div>
      <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
        <input type="checkbox" id="productFeedbackCheck" style="margin: 0; cursor: pointer;">
        <label for="productFeedbackCheck" style="color: var(--text-secondary); font-size: 12px; cursor: pointer; margin: 0;">Product Feedback</label>
      </div>
      <div style="display: flex; gap: 8px;">
        <input type="text" id="chatInput" placeholder="Type a message..." style="flex: 1; padding: 8px; background: var(--bg); border: 1px solid var(--border); color: var(--text); border-radius: 4px;" onkeypress="if(event.key==='Enter') sendChatMessage()">
        <button onclick="sendChatMessage()" class="primary">Send</button>
      </div>
    </div>
  </div>

  <div id="phoneModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 1000; align-items: center; justify-content: center;">
    <div style="background: var(--panel); padding: 20px; border-radius: 10px; border: 1px solid var(--border); width: 320px;">
      <h3 style="margin-top: 0; color: var(--accent);">Update Phone & Send Welcome</h3>
      
      <div style="margin-bottom: 15px;">
        <label style="display: block; font-size: 12px; color: var(--muted); margin-bottom: 5px;">Phone Number</label>
        <input type="text" id="modalPhoneInput" style="width: 100%; padding: 8px; background: var(--bg); border: 1px solid var(--border); color: var(--text); border-radius: 4px;" placeholder="e.g. 6199773020">
      </div>

      <div style="margin-bottom: 15px;">
        <label style="display: block; font-size: 12px; color: var(--muted); margin-bottom: 5px;">Signed Up By (Budtender)</label>
        <select id="modalBudtenderSelect" style="width: 100%; padding: 8px; background: var(--bg); border: 1px solid var(--border); color: var(--text); border-radius: 4px;" onchange="toggleOtherInput()">
          <option value="">Select Budtender...</option>
        </select>
        <input type="text" id="modalBudtenderOther" style="display: none; width: 100%; margin-top: 5px; padding: 8px; background: var(--bg); border: 1px solid var(--border); color: var(--text); border-radius: 4px;" placeholder="Type name...">
        <div style="font-size: 10px; color: var(--muted); margin-top: 4px;"></div>
      </div>

      <div style="display: flex; justify-content: flex-end; gap: 10px;">
        <button class="btn" onclick="closePhoneModal()" style="background: transparent; border: 1px solid var(--border);">Cancel</button>
        <button class="btn primary" onclick="savePhoneModal()">Save & Send</button>
      </div>
    </div>
  </div>

  <script>
    const SUPABASE_URL = "https://kiwmwoqrguyrcpjytgte.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imtpd213b3FyZ3V5cmNwanl0Z3RlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk4NDUwNTEsImV4cCI6MjA3NTQyMTA1MX0.3YhobdFv0ZV6PzExcr88l-zNN3vZeEsM_Du9kVEmdV0";

    let supabase = null;
    let queue = [];
    let selectedCustomerId = null;
    let selectedCustomerPhone = null;
    let pinnedCustomers = []; // Array of customer IDs that are pinned
    let currentView = 'dashboard';
    let currentConversationPhone = null;
    let currentConversationPhoneKey = null;
    let currentConversationCustomerId = null;
    let syncTimer = null;
    let isPaused = false;
    let budtenderCache = {};

    // --- TEAM CHAT FUNCTIONS ---
    let chatRealtime = null;
    let chatModalOpen = false;
    let lastChatMessageId = null;

    function openChatModal() {
        chatModalOpen = true;
        document.getElementById('chatModal').style.display = 'flex';
        loadChatHistory();
        subscribeToChat();
        
        // Clear pulse when opening
        const chatBtn = document.getElementById('chatBtn');
        if (chatBtn) {
            chatBtn.classList.remove('pulse-red');
        }
        
        // Populate identity dropdown if empty
        const select = document.getElementById('chatIdentity');
        if (select.options.length <= 1) {
            const priorityNames = [
              "Grace", "50", "Cherish", "Jimmy", "Leo", 
              "Jacob", "John", "Lizbeth", "Joaq", "Luis", 
              "Agustin", "Devon", "Stephen", "Aaron"
            ];
            priorityNames.forEach(name => {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name;
                select.appendChild(opt);
            });
            
            // Load saved identity
            const savedId = localStorage.getItem('mota_chat_identity');
            if (savedId) select.value = savedId;
        }
    }

    function closeChatModal() {
        chatModalOpen = false;
        document.getElementById('chatModal').style.display = 'none';
        // Don't remove channel - keep listening for pulse notifications
        // The subscription stays active so we can pulse when new messages arrive
    }

    async function loadChatHistory() {
        const container = document.getElementById('chatMessages');
        const { data, error } = await supabase
            .from('messages')
            .select('*')
            .eq('status', 'chat')
            .order('timestamp', { ascending: true }) // Oldest first
            .limit(50);

        if (error) {
            console.error("Chat error:", error);
            container.innerHTML = `<div class="error" style="color: #ef4444; padding: 20px; text-align: center;">Error: ${error.message}</div>`;
            return;
        }

        container.innerHTML = '';
        data.forEach(msg => appendChatMessage(msg));
        
        // Track last message ID for pulse detection
        if (data.length > 0) {
            lastChatMessageId = data[data.length - 1].id;
        }
        
        container.scrollTop = container.scrollHeight;
    }

    function appendChatMessage(msg) {
        const container = document.getElementById('chatMessages');
        const sender = msg.payload?.sender || 'Unknown';
        const time = new Date(msg.timestamp || new Date()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const isProductFeedback = msg.payload?.product_feedback || false;
        
        const msgDiv = document.createElement('div');
        msgDiv.style.marginBottom = '8px';
        msgDiv.style.position = 'relative';
        msgDiv.dataset.messageId = msg.id;
        msgDiv.innerHTML = `
            <div style="font-size: 10px; color: var(--accent); font-weight: 700; margin-bottom: 2px; display: flex; justify-content: space-between; align-items: center;">
                <span>${sender} <span style="color: var(--text-secondary); font-weight: 400;">${time}</span> ${isProductFeedback ? '<span style="color: #f59e0b; font-size: 9px;">üìù Product Feedback</span>' : ''}</span>
                <button onclick="deleteChatMessage('${msg.id}')" class="chat-delete-btn" style="display: none; background: transparent; border: none; color: #ef4444; cursor: pointer; font-size: 14px; padding: 2px 6px; opacity: 0.6; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.6'" title="Delete message">üóëÔ∏è</button>
            </div>
            <div style="background: #2d3748; padding: 8px 12px; border-radius: 8px; font-size: 13px; line-height: 1.4; color: #e2e8f0;">
                ${msg.content}
            </div>
        `;
        
        // Show delete button on hover
        msgDiv.addEventListener('mouseenter', () => {
            const btn = msgDiv.querySelector('.chat-delete-btn');
            if (btn) btn.style.display = 'block';
        });
        msgDiv.addEventListener('mouseleave', () => {
            const btn = msgDiv.querySelector('.chat-delete-btn');
            if (btn) btn.style.display = 'none';
        });
        
        container.appendChild(msgDiv);
        container.scrollTop = container.scrollHeight;
    }
    
    async function deleteChatMessage(messageId) {
        if (!confirm("Delete this message?")) return;
        
        const { error } = await supabase
            .from('messages')
            .delete()
            .eq('id', messageId);
            
        if (error) {
            alert("Failed to delete: " + error.message);
            return;
        }
        
        // Remove from UI
        const msgDiv = document.querySelector(`[data-message-id="${messageId}"]`);
        if (msgDiv) msgDiv.remove();
    }

    async function sendChatMessage() {
        const input = document.getElementById('chatInput');
        const select = document.getElementById('chatIdentity');
        const productFeedbackCheck = document.getElementById('productFeedbackCheck');
        const content = input.value.trim();
        const sender = select.value;
        const isProductFeedback = productFeedbackCheck ? productFeedbackCheck.checked : false;

        if (!content) return;
        if (!sender) {
            alert("Please select who you are!");
            return;
        }

        // Save identity
        localStorage.setItem('mota_chat_identity', sender);

        input.value = '';
        if (productFeedbackCheck) productFeedbackCheck.checked = false;
        
        const { error } = await supabase.from('messages').insert({
            phone_number: 'TEAM',
            direction: 'internal',
            status: 'chat',
            content: content,
            payload: { 
                sender: sender,
                product_feedback: isProductFeedback
            }
        });
        
        if (error) {
            alert("Failed to send message: " + error.message);
        }
    }

    function subscribeToChat() {
        // Only create one subscription
        if (chatRealtime) return;
        
        chatRealtime = supabase.channel('team-chat')
            .on(
                'postgres_changes',
                { event: 'INSERT', schema: 'public', table: 'messages', filter: 'status=eq.chat' },
                (payload) => {
                    // If modal is open, append the message
                    if (chatModalOpen) {
                        appendChatMessage(payload.new);
                        lastChatMessageId = payload.new.id;
                    } else {
                        // Modal is closed - pulse the button to notify!
                        const chatBtn = document.getElementById('chatBtn');
                        if (chatBtn) {
                            chatBtn.classList.add('pulse-red');
                        }
                    }
                }
            )
            .subscribe();
    }

    // --- END TEAM CHAT ---

    function fmtCurrency(num) {
      return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(num);
    }

    function fmtDateShort(iso) {
      if (!iso) return 'N/A';
      const d = new Date(iso);
      return new Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true }).format(d);
    }

    function toTitleCase(str) {
      if (!str) return "";
      return str.replace(
        /\w\S*/g,
        function(txt) {
          return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        }
      );
    }

    function normalizePhone(phone) {
      return (phone + "").replace(/\D/g, "");
    }

    function decodeHexUCS2(hex) {
      if (!hex) return "";
      // Simple check if it looks like hex
      if (!/^[0-9a-fA-F]+$/.test(hex) || hex.length % 4 !== 0) return hex;
      
      let str = "";
      for (let i = 0; i < hex.length; i += 4) {
        const code = parseInt(hex.substr(i, 4), 16);
        str += String.fromCharCode(code);
      }
      return str;
    }

    async function initSupabase() {
      supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    }

    function updateStatus(text) {
      const badge = document.getElementById('pollStatus');
      if (badge) badge.textContent = text;
    }

    // Load budtender names from Supabase using employee_id
    async function loadBudtenderNames(sellerIds) {
      try {
        const unknownIds = sellerIds.filter(id => !budtenderCache[id]);
        if (unknownIds.length === 0) return;

        const btResp = await supabase
          .from('employees_blaze')
          .select('employee_id, first_name, last_name')
          .in('employee_id', unknownIds);

        if (btResp.data) {
          btResp.data.forEach(b => {
            budtenderCache[b.employee_id] = `${b.first_name || ''} ${b.last_name || ''}`.trim();
          });
        }

        unknownIds.forEach(id => {
          if (!budtenderCache[id]) {
            budtenderCache[id] = id.slice(0, 8);
          }
        });
      } catch (e) {
        console.warn('Budtender lookup:', e);
        sellerIds.forEach(id => {
          if (!budtenderCache[id]) {
            budtenderCache[id] = id.slice(0, 8);
          }
        });
      }
    }

    async function fetchQueue() {
      if (isPaused) return;
      if (!supabase) await initSupabase();
      updateStatus('Syncing...');

      try {
        const EDGE_FUNCTION_URL = 'https://kiwmwoqrguyrcpjytgte.supabase.co/functions/v1/blaze_proxy';
        
        const txResponse = await fetch(EDGE_FUNCTION_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'getActiveTransactions' })
        });

        if (!txResponse.ok) throw new Error('Failed to fetch queue');

        const txData = await txResponse.json();
        const values = txData?.values || [];

        queue = [];
        const memberIds = [...new Set(values.map(tx => tx.memberId).filter(Boolean))];

        for (const memberId of memberIds) {
          try {
            const memberResponse = await fetch(EDGE_FUNCTION_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ action: 'getMemberDetails', memberId: memberId })
            });

            if (memberResponse.ok) {
              const member = await memberResponse.json();
              const tx = values.find(t => t.memberId === memberId);

              if (tx) {
                const fullName = `${member.firstName || ''} ${member.lastName || ''}`.trim() || 'Unknown';
                queue.push({
                  customer_id: memberId,
                  customer_name: toTitleCase(fullName),
                  phone: member.mobileNumber || member.phone || null,
                  check_in_time: new Date(tx.checkinTime || tx.created),
                  vip_status: member.loyaltyStatus === 'VIP',
                  status: tx.status || 'InProgress'
                });
              }
            }
          } catch (e) {
            console.warn('Error fetching member:', e);
          }
        }

        renderQueue();
        updateStatus(`${queue.length} in queue`);

        if (queue.length > 0 && !selectedCustomerId) {
          selectCustomer(queue[0].customer_id);
        }
      } catch (e) {
        console.error('Sync error:', e);
        updateStatus('Sync Failed');
      }
    }

    function renderQueue() {
      const container = document.getElementById('queueList');
      if (!container) return;
      
      // Separate pinned and unpinned
      const unpinned = queue.filter(c => !pinnedCustomers.includes(c.customer_id));
      const pinned = queue.filter(c => pinnedCustomers.includes(c.customer_id));
      
      // Render unpinned first, then pinned at bottom
      const allCustomers = [...unpinned, ...pinned];
      
      container.innerHTML = allCustomers.map(customer => {
        const isPinned = pinnedCustomers.includes(customer.customer_id);
        const isSelected = selectedCustomerId === customer.customer_id;
        
        return `
          <div class="queue-item ${isSelected ? 'selected' : ''} ${isPinned ? 'pinned' : ''}" 
               onclick="selectCustomer('${customer.customer_id}')"
               style="display: flex; justify-content: space-between; align-items: center;">
            <div style="flex: 1;">
              <div class="queue-name">${customer.customer_name}${customer.vip_status ? ' ‚≠ê' : ''}</div>
              <div class="queue-meta">
                <span>${customer.check_in_time.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true })}</span>
                <span>${customer.phone ? 'üì±' : '‚ö†Ô∏è'}</span>
              </div>
            </div>
            <span class="pin-icon" 
                  onclick="event.stopPropagation(); togglePin('${customer.customer_id}')"
                  style="padding: 4px 8px; cursor: pointer; font-size: 14px; opacity: ${isPinned ? '1' : '0.3'};"
                  title="${isPinned ? 'Unpin' : 'Pin'}">
              üìå
            </span>
          </div>
        `;
      }).join('');
    }

    async function selectCustomer(customerId) {
      selectedCustomerId = customerId;
      renderQueue();
      loadCustomerCard(customerId);
    }

    // Column resizing logic
    const columnWidths = {
      queuePanel: 320,
      colLeft: 300,
      colCenter: 400,
      colRight: 300
    };

    function resizeColumn(colId, delta) {
      const el = document.getElementById(colId);
      if (!el) return;
      
      let current = el.offsetWidth;
      // For flex columns (colLeft, colCenter, colRight), we might need to check style.width first or use offsetWidth
      // We need to update style.width and style.flex basis
      
      let newWidth = current + delta;
      
      // Apply limits
      if (newWidth < 200) newWidth = 200;
      if (newWidth > 800) newWidth = 800;
      
      // Apply to element
      if (colId === 'queuePanel') {
        el.style.width = `${newWidth}px`;
        el.style.flex = `0 0 ${newWidth}px`;
      } else {
        // For content columns, we update flex-basis or width
        // Since we used % before, we switch to px now for precise control
        el.style.width = `${newWidth}px`;
        el.style.flex = `0 0 ${newWidth}px`;
        el.style.minWidth = `${newWidth}px`;
      }
      
      // Save preference
      columnWidths[colId] = newWidth;
      localStorage.setItem('checkin_monitor_widths', JSON.stringify(columnWidths));
    }

    // Load saved widths
    function loadColumnWidths() {
      try {
        const saved = localStorage.getItem('checkin_monitor_widths');
        if (saved) {
          const widths = JSON.parse(saved);
          Object.assign(columnWidths, widths);
          
          Object.keys(widths).forEach(id => {
            const el = document.getElementById(id);
            if (el) {
              el.style.width = `${widths[id]}px`;
              el.style.flex = `0 0 ${widths[id]}px`;
              el.style.minWidth = `${widths[id]}px`;
            }
          });
        }
      } catch(e) { console.error("Error loading widths", e); }
    }

    async function loadCustomerCard(customerId) {
      let customer = queue.find(p => p.customer_id === customerId);
      if (!customer) return;

      try {
        // 1. Fetch latest profile from Supabase (Priority: customers -> customers_blaze)
        // Try member_id first
        let { data: sbCustomer } = await supabase
          .from('customers')
          .select('*')
          .eq('member_id', customerId)
          .single();
          
        // Fallback: Try finding by ID if member_id didn't work
        if (!sbCustomer) {
           const { data: byId } = await supabase.from('customers').select('*').eq('id', customerId).single();
           if (byId) sbCustomer = byId;
        }

        if (sbCustomer) {
          // Found in main customers table
          if (sbCustomer.phone) customer.phone = sbCustomer.phone;
          if (sbCustomer.first_name) customer.customer_name = toTitleCase(`${sbCustomer.first_name} ${sbCustomer.last_name}`);
        } else {
          // Fallback to customers_blaze
          // Try member_id first
          let { data: sbBlaze } = await supabase
            .from('customers_blaze')
            .select('*')
            .eq('member_id', customerId)
            .single();
            
          // Fallback: Try ID
          if (!sbBlaze) {
             const { data: bById } = await supabase.from('customers_blaze').select('*').eq('id', customerId).single();
             if (bById) sbBlaze = bById;
          }
          
          if (sbBlaze) {
             if (sbBlaze.phone || sbBlaze.phone_number) customer.phone = sbBlaze.phone || sbBlaze.phone_number;
             if (sbBlaze.first_name) customer.customer_name = toTitleCase(`${sbBlaze.first_name} ${sbBlaze.last_name}`);
          }
        }
        
        // Fallback: If we still don't have a phone but we have a name, try looking up by name?
        // Or relying on the queue data if available (some integrations provide phone)

        // Update phone global
        selectedCustomerPhone = customer.phone || customer.phone_number;
        customer.phone = selectedCustomerPhone; // Ensure property is set

        // Update the queue item in place so the list reflects it too
        const qItem = queue.find(q => q.customer_id === customerId);
        if (qItem) {
          qItem.phone = customer.phone;
          renderQueue(); // Refresh the list to show phone icon if we found one
        }

        // Load SMS Thread immediately
        loadSmsThread(customer.phone);
        
        // Load Journey
        loadHeroJourney(customer);

        // Fetch transactions - ensure we query by the correct ID
        // Transactions usually linked by customer_id (member_id string)
        const r = await supabase
          .from('transactions')
          .select('transaction_id, date, created_at, total_amount, seller_id, customer_id')
          .eq('customer_id', customerId)
          .order('date', { ascending: false })
          .limit(500);

        let transactions = r.data || [];

        let items = [];
        if (transactions.length > 0) {
          const txIds = transactions.map(t => t.transaction_id).filter(Boolean);
          const itemsResp = await supabase
            .from('transaction_items_blaze')
            .select('transaction_id, product_name, brand, category, total_price, unit_price, quantity, final_price')
            .in('transaction_id', txIds);
          items = itemsResp.data || [];
        }

        const sellerIds = [...new Set(transactions.map(t => t.seller_id).filter(Boolean))];
        await loadBudtenderNames(sellerIds);

        renderCard(customer, transactions, items);
      } catch (e) {
        console.error('Error loading card:', e);
        document.getElementById('categoriesContent').textContent = `Error: ${e.message}`;
      }
    }

    // SMS FUNCTIONS
    async function loadSmsThread(phone) {
      const container = document.getElementById("smsThread");
      const statusEl = document.getElementById("smsStatus");
      
      if (!phone) {
        container.innerHTML = '<div class="muted" style="text-align: center; padding: 20px;">No phone number available</div>';
        statusEl.textContent = "No Phone";
        return;
      }

      container.innerHTML = '<div class="muted" style="text-align: center; padding: 20px;">Loading messages...</div>';
      statusEl.textContent = phone;

      try {
        const digits = normalizePhone(phone);
        const ilikePattern = `%${digits}%`;
        
        // Match messages flexibly
        const { data: messages, error } = await supabase
          .from("messages")
          .select("id, content, direction, status, timestamp, phone_number")
          .ilike("phone_number", ilikePattern)
          .in("status", ["sent", "read", "unread", "queued", "failed", "delivered", "rejected", "QUE", "scheduled"])
          .order("timestamp", { ascending: true })
          .limit(100);
        
        if (error) throw error;
        
        // Strict filter
        const filtered = (messages || []).filter(m => normalizePhone(m.phone_number) === digits);
        
        if (filtered.length === 0) {
          container.innerHTML = '<div class="muted" style="text-align: center; padding: 20px;">No message history</div>';
          return;
        }
        
        container.innerHTML = filtered.map(m => {
          const isInbound = m.direction === "inbound";
          const bubbleClass = isInbound ? "inbound" : "outbound";
          const time = new Date(m.timestamp).toLocaleString();
          const status = m.status ? `<span class="bubble-status">${m.status.toUpperCase()}</span>` : "";
          const decoded = decodeHexUCS2(m.content || "");
          const content = decoded.replace(/\n/g, "<br>");
          
          return `
            <div class="msg-bubble ${bubbleClass}">
              <div>${content}</div>
              <div class="bubble-time">${time} ${status}</div>
            </div>
          `;
        }).join("");
        
        container.scrollTop = container.scrollHeight;
      } catch (e) {
        console.error("Error loading SMS:", e);
        container.innerHTML = '<div class="muted" style="text-align: center; padding: 20px;">Error loading messages</div>';
      }
    }

    // HERO'S JOURNEY FUNCTIONS
    async function loadHeroJourney(customer) {
      const container = document.getElementById('journeyContent');
      if (!customer.customer_id) {
        container.innerHTML = '<div class="muted">No customer selected</div>';
        return;
      }

      try {
        // Fetch Journey Events (Messages with 'journey_step' payload)
        const { data: journeyEvents, error } = await supabase
          .from('messages')
          .select('payload, created_at')
          .eq('phone_number', customer.phone) // Use phone as key
          .not('payload', 'is', null);

        if (error) throw error;

        // Extract completed steps
        const completedSteps = new Set();
        (journeyEvents || []).forEach(msg => {
           if (msg.payload && msg.payload.journey_step) {
             completedSteps.add(msg.payload.journey_step);
           }
        });

        // Check for Campaign Runs (Sent Texts)
        // We need member_id for this
        const { data: campRuns } = await supabase
          .from('sms_campaign_runs')
          .select('campaign_id') // Ideally join campaign name, but we'll map ID or just infer
          .eq('customer_id', customer.customer_id); // member_id
          
        // Since we don't have campaign names easily joined without another query,
        // let's just check if they exist. For now, we'll assume if 'journey_step' exists, it's done.
        // Actually, user wants "Sent Text" vs "Gift Given".
        // Let's look for messages with specific campaign_names in 'messages' table too?
        // The messages table has 'campaign_name' column.
        
        const { data: sentCampaigns } = await supabase
          .from('messages')
          .select('campaign_name')
          .eq('phone_number', customer.phone)
          .not('campaign_name', 'is', null);
          
        const sentSet = new Set((sentCampaigns || []).map(m => m.campaign_name));

        // Define Steps
        const steps = [
          {
            title: "1. The Welcome",
            substeps: [
              { id: 'welcome_text', label: 'Sent: Welcome Text', type: 'auto', check: sentSet.has('new_customer_retention') },
              { id: 'welcome_fatty', label: 'Done: Free Fatty Given', type: 'manual', check: completedSteps.has('welcome_fatty') }
            ]
          },
          {
            title: "2. The Check-In",
            substeps: [
              { id: 'feedback_text', label: 'Sent: Feedback Text', type: 'auto', check: sentSet.has('casual_feedback_fatty') },
              { id: 'feedback_reward', label: 'Done: Reward Given', type: 'manual', check: completedSteps.has('feedback_reward') }
            ]
          }
        ];

        // Render
        let html = '';
        steps.forEach(section => {
          html += `<div style="margin-bottom: 8px;">
            <div style="font-weight: 700; font-size: 11px; color: var(--accent); margin-bottom: 4px;">${section.title}</div>`;
          
          section.substeps.forEach(step => {
            const isChecked = step.check ? 'checked' : '';
            const isDisabled = step.type === 'auto' ? 'disabled' : '';
            const opacity = step.type === 'auto' ? '0.7' : '1';
            const cursor = step.type === 'auto' ? 'default' : 'pointer';
            const onClick = step.type === 'manual' && !step.check ? `onclick="completeJourneyStep('${customer.phone}', '${step.id}')"` : '';
            
            // Visual style for checked manual
            const statusColor = step.check ? 'var(--accent)' : 'var(--text-secondary)';
            const icon = step.check ? '‚úÖ' : '‚¨ú';
            
            if (step.type === 'auto') {
               html += `<div style="display: flex; align-items: center; gap: 6px; font-size: 11px; opacity: ${opacity}; margin-bottom: 2px;">
                 <span>${step.check ? 'üì®' : '‚è≥'}</span> ${step.label}
               </div>`;
            } else {
               html += `<div ${onClick} style="display: flex; align-items: center; gap: 6px; font-size: 11px; cursor: ${cursor}; margin-bottom: 2px;">
                 <span>${icon}</span> <span style="color: ${statusColor}">${step.label}</span>
               </div>`;
            }
          });
          
          html += `</div>`;
        });

        container.innerHTML = html;

      } catch (e) {
        console.error("Error loading journey:", e);
        container.innerHTML = '<div class="muted">Error loading journey</div>';
      }
    }

    async function completeJourneyStep(phone, stepId) {
      if (!confirm("Confirm this step is complete?")) return;
      
      try {
        const { error } = await supabase.from('messages').insert({
          phone_number: phone,
          direction: 'inbound', // Use inbound to denote internal log/action
          status: 'read',       // Mark as read so it doesn't clog inbox
          content: `[JOURNEY] Completed: ${stepId}`,
          payload: {
            journey_step: stepId,
            completed_at: new Date().toISOString(),
            type: 'manual_completion'
          }
        });

        if (error) throw error;
        
        // Refresh
        const customer = queue.find(c => c.phone === phone || normalizePhone(c.phone) === normalizePhone(phone));
        if (customer) loadHeroJourney(customer);
        
      } catch (e) {
        alert("Failed to save step: " + e.message);
      }
    }

    async function sendSmsReply() {
      if (!selectedCustomerPhone) {
        alert("No phone number for this customer.");
        return;
      }
      
      const content = (document.getElementById("smsReplyText")?.value || "").trim();
      if (!content) {
        alert("Please enter a message.");
        return;
      }
      
      try {
        const { error } = await supabase.from("messages").insert({
          phone_number: selectedCustomerPhone,
          content: content,
          direction: "outbound",
          status: "queued",
          timestamp: new Date().toISOString()
        });
        
        if (error) throw error;
        
        alert("Message queued.");
        document.getElementById("smsReplyText").value = "";
        
        // Reload thread
        await loadSmsThread(selectedCustomerPhone);
      } catch (e) {
        console.error("Error sending SMS:", e);
        alert("Failed to send: " + e.message);
      }
    }

    document.getElementById("smsReplyText").addEventListener("input", function() {
      const len = this.value.length;
      const el = document.getElementById("smsCharCount");
      el.textContent = `${len} / 160`;
      el.style.color = len > 160 ? "var(--warn)" : "var(--text-secondary)";
    });

    // Modal Global Vars
    let modalCustomerId = null;
    let modalCurrentName = "";

    async function addPhoneNumber(customerId, currentPhone = '', customerName = '') {
      // 1. PAUSE SYNC
      stopSync();
      
      modalCustomerId = customerId;
      modalCurrentName = customerName || "Friend"; 
      
      // Populate modal
      document.getElementById('modalPhoneInput').value = currentPhone || '';
      // Default to Grace if available, else first option
      document.getElementById('modalBudtenderSelect').value = "Grace"; 
      document.getElementById('modalBudtenderOther').value = "";
      document.getElementById('modalBudtenderOther').style.display = "none";
      
      // Show modal
      document.getElementById('phoneModal').style.display = 'flex';
      document.getElementById('modalPhoneInput').focus();
      
      document.addEventListener('keydown', handleModalKeys);
    }

    function toggleOtherInput() {
      const select = document.getElementById('modalBudtenderSelect');
      const otherInput = document.getElementById('modalBudtenderOther');
      if (select.value === 'Other') {
        otherInput.style.display = 'block';
        otherInput.focus();
      } else {
        otherInput.style.display = 'none';
      }
    }

    function closePhoneModal() {
      document.getElementById('phoneModal').style.display = 'none';
      document.removeEventListener('keydown', handleModalKeys);
      startSync();
    }

    function handleModalKeys(e) {
      if (document.getElementById('phoneModal').style.display === 'none') return;
      
      // If editing "Other" input, allow typing
      if (document.activeElement === document.getElementById('modalBudtenderOther')) {
        if (e.key === 'Enter') savePhoneModal();
        return;
      }

      // If phone input is focused, don't hijack keys unless it's Enter
      if (document.activeElement === document.getElementById('modalPhoneInput')) {
        if (e.key === 'Enter') {
           // Could move focus to select, but saving is fine
           // savePhoneModal(); 
        }
        return;
      }
      
      if (e.key === 'Enter') {
        savePhoneModal();
      }
      
      // Shortcuts (only if not typing in inputs)
      // REMOVED per user request: "no shortcusts like that at all i want like just the fucking drop down lol"
      /*
      if (document.activeElement !== document.getElementById('modalPhoneInput') && 
          document.activeElement !== document.getElementById('modalBudtenderSelect') &&
          document.activeElement !== document.getElementById('modalBudtenderOther')) {
         
         const select = document.getElementById('modalBudtenderSelect');
         const key = e.key.toLowerCase();
         
         if (key === 'g') select.value = "Grace";
         if (key === 'd') select.value = "Devon";
         if (key === '5') select.value = "50";
         
         // If shortcut used, ensure 'Other' input is hidden
         toggleOtherInput();
      }
      */
    }

    async function savePhoneModal() {
      const phone = document.getElementById('modalPhoneInput').value.trim();
      const selectVal = document.getElementById('modalBudtenderSelect').value;
      const otherVal = document.getElementById('modalBudtenderOther').value.trim();
      
      // Determine final budtender name
      let budtender = selectVal;
      if (selectVal === 'Other') {
        budtender = otherVal;
      }
      
      const customerId = modalCustomerId;
      
      if (!phone) {
        alert("Please enter a phone number.");
        return;
      }
      
      // Basic validation
      const digits = phone.replace(/\D/g, "");
      if (digits.length < 10) {
        alert("Please enter a valid phone number with at least 10 digits.");
        return;
      }

      // Hide modal but keep sync stopped until done
      document.getElementById('phoneModal').style.display = 'none';
      document.removeEventListener('keydown', handleModalKeys);
      
      try {
        updateStatus('Updating...');
        
        // 2. Optimistic Update
        const qItem = queue.find(q => q.customer_id === customerId);
        if (qItem) {
           qItem.phone = phone;
           if (selectedCustomerId === customerId) selectedCustomerPhone = phone;
        }
        renderQueue();

        // 3. Update Supabase
        const updates = [];
        
        updates.push(
          supabase.from('customers_blaze').update({ phone: phone }).eq('member_id', customerId)
        );
        updates.push(
          supabase.from('customers').update({ phone: phone }).eq('member_id', customerId)
        );
        
        // 4. Log manual update with Budtender credit
        // Map nicknames to DB names if needed for reporting? 
        // User asked to link them to DB table.
        // "Grace" -> "Graciela Bobadilla"
        // "50" -> "Roderick Fraizer"
        
        let dbBudtenderName = budtender;
        if (budtender === "Grace") dbBudtenderName = "Graciela Bobadilla";
        if (budtender === "50") dbBudtenderName = "Roderick Fraizer";
        
        updates.push(
          supabase.from('messages').insert({
            phone_number: phone,
            direction: 'internal',
            status: 'log',
            content: `Manual phone update: ${phone} by ${budtender || 'Unknown'}`,
            timestamp: new Date().toISOString(),
            payload: {
              type: 'manual_phone_update',
              customer_id: customerId,
              updated_at: new Date().toISOString(),
              signup_by: dbBudtenderName, // Use DB name for tracking
              signup_display: budtender // Keep display name for reference
            }
          })
        );
        
        // 5. Generate & Queue Welcome Message
        if (budtender) {
           const firstName = toTitleCase(modalCurrentName.split(' ')[0] || "Friend");
           const welcomeMsg = `Hey ${firstName}\n\nCongratulations on joining Mota Rewards,\n\nPlease reply redeem for your free joint!\n\n-${budtender}\n\n@ -4001 Sunset Blvd.`;
           
           updates.push(
             supabase.from('messages').insert({
               phone_number: phone,
               content: welcomeMsg,
               direction: 'outbound',
               status: 'queued',
               timestamp: new Date().toISOString(),
               payload: {
                 type: 'welcome_text',
                 signup_by: dbBudtenderName, // Credit assignment
                 customer_id: customerId
               }
             })
           );
        }

        await Promise.all(updates);

        // 6. Call Proxy
        const EDGE_FUNCTION_URL = 'https://kiwmwoqrguyrcpjytgte.supabase.co/functions/v1/blaze_proxy';
        fetch(EDGE_FUNCTION_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            action: 'updatePhoneNumber', 
            customerId: customerId,
            phone: phone
          })
        }).catch(err => console.warn("Proxy update failed (non-critical):", err));

        // Success
        alert("Phone saved & Welcome text queued!");
        updateStatus('Updated');
        
        setTimeout(() => {
           if (customerId) {
             loadCustomerCard(customerId);
             const qItem = queue.find(q => q.customer_id === customerId);
             if (qItem) qItem.phone = phone;
             renderQueue();
           }
           startSync(); 
        }, 500);

      } catch (e) {
        console.error('Error updating phone:', e);
        alert(`Error: ${e.message}`);
        startSync();
      }
    }

    function renderCard(customer, transactions, items) {
      const visits = transactions.length;
      const totalSpend = transactions.reduce((sum, tx) => sum + (parseFloat(tx.total_amount) || 0), 0);
      const avgTxValue = visits > 0 ? (totalSpend / visits) : 0;

      document.getElementById('stat-lifetime').textContent = fmtCurrency(totalSpend);
      document.getElementById('stat-visits').textContent = visits;
      document.getElementById('stat-avg').textContent = fmtCurrency(avgTxValue);
      document.getElementById('stat-last').textContent = transactions.length > 0 ? fmtDateShort(transactions[0].date) : '‚Äî';

      const headerDiv = document.getElementById('headerCard').querySelector('.customer-info');
      const phoneHtml = customer.phone 
        ? `<span style="cursor: pointer;" onclick="addPhoneNumber('${customer.customer_id}', '${customer.phone}', '${customer.customer_name.replace(/'/g, "\\'")}')" title="Click to edit">${customer.phone} ‚úèÔ∏è</span>` 
        : `<span style="color: var(--danger); cursor: pointer; display: flex; align-items: center; gap: 4px;" onclick="addPhoneNumber('${customer.customer_id}', '', '${customer.customer_name.replace(/'/g, "\\'")}')">‚ö†Ô∏è Add Number <span style="font-size: 10px; background: var(--danger); color: white; padding: 1px 4px; border-radius: 3px;">+</span></span>`;

      headerDiv.innerHTML = `
        <div class="customer-name">${customer.customer_name}</div>
        <div class="customer-meta">
          ${customer.vip_status ? '<span class="vip-tag">VIP</span>' : 'Regular'}
          <span>‚Ä¢</span>
          ${phoneHtml}
        </div>
      `;

      // Categories & Brands
      const categorySpend = {};
      const brandSpend = {};
      
      items.forEach(item => {
        const price = parseFloat(item.final_price) || (Number(item.quantity || 1) * Number(item.unit_price || 0));
        const brand = (item.brand || 'Unknown').trim();
        const blazeCategory = (item.category || '').trim();

        categorySpend[blazeCategory || 'Unknown'] = (categorySpend[blazeCategory || 'Unknown'] || 0) + price;
        brandSpend[brand] = (brandSpend[brand] || 0) + price;
      });

      const topCats = Object.entries(categorySpend)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([cat, spend]) => `<div class="data-row"><span class="data-label">${cat}</span> <span class="data-value">${fmtCurrency(spend)}</span></div>`)
        .join('');

      const topBrands = Object.entries(brandSpend)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([brand, spend]) => `<div class="data-row"><span class="data-label">${brand}</span> <span class="data-value">${fmtCurrency(spend)}</span></div>`)
        .join('');

      document.getElementById('categoriesContent').innerHTML = topCats || '<div class="data-label">No data</div>';
      document.getElementById('brandsContent').innerHTML = topBrands || '<div class="data-label">No data</div>';

      // Visit Pattern (Last 12 Months Fixed)
      const last12Months = [];
      const today = new Date();
      for (let i = 0; i < 12; i++) {
        const d = new Date(today.getFullYear(), today.getMonth() - i, 1);
        const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
        last12Months.push(key);
      }

      const monthlyVisits = {};
      transactions.forEach(tx => {
        const d = new Date(tx.date || tx.created_at);
        const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
        monthlyVisits[key] = (monthlyVisits[key] || 0) + 1;
      });

      const chartData = last12Months.map(key => {
        const [year, month] = key.split('-');
        return {
          label: `${parseInt(month)}/${year.slice(2)}`,
          count: monthlyVisits[key] || 0
        };
      });

      const maxVisits = Math.max(...chartData.map(d => d.count), 1);
      const chartHtml = chartData.map(d => `
          <div class="chart-row">
            <span class="chart-month">${d.label}</span>
            <div class="chart-bar-bg">
              <div class="chart-bar" style="width: ${(d.count / maxVisits * 100).toFixed(0)}%;"></div>
            </div>
            <span class="chart-count">${d.count || ''}</span>
          </div>
        `).join('');

      document.getElementById('analyticsContent').innerHTML = `<div class="chart-container">${chartHtml || '<div class="data-label">No data</div>'}</div>`;

      // Top Items
      const itemCounts = {};
      items.forEach(item => {
        const productName = item.product_name && item.product_name.toLowerCase() !== 'null' ? item.product_name : 'Unknown';
        const key = `${productName} (${item.brand || 'Unknown'})`;
        itemCounts[key] = (itemCounts[key] || 0) + 1;
      });

      const topItems = Object.entries(itemCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 7)
        .map(([name, count], i) => `
          <div class="item-row">
            <span class="item-rank">${i + 1}.</span>
            <span class="item-name">${name}</span>
            <span class="item-count">√ó${count}</span>
          </div>
        `).join('');

      document.getElementById('itemsContent').innerHTML = topItems || '<div class="data-label">No data</div>';

      // Last 5 Visits
      const visitsHtml = transactions.slice(0, 5).map(tx => {
        const txItems = items.filter(i => i.transaction_id === tx.transaction_id);
        
        const itemsHtml = txItems.map(i => {
          const name = i.product_name || 'Unknown';
          const qty = i.quantity > 1 ? ` <span style="color:var(--accent); font-weight:700;">(√ó${i.quantity})</span>` : '';
          return `<div style="margin-bottom: 6px; padding-left: 10px; border-left: 2px solid var(--border-light); line-height: 1.3;">
            <div style="color: var(--text); font-weight: 500;">${name}${qty}</div>
            <div style="color: var(--text-secondary); font-size: 10px;">${i.category || ''}</div>
          </div>`;
        }).join('');

        const budtender = budtenderCache[tx.seller_id] || 'Unknown';
        const date = fmtDateShort(tx.date);

        return `
          <tr>
            <td class="visit-date" style="vertical-align: top; padding-top: 12px;">${date}</td>
            <td class="visit-items" style="padding: 12px 8px;">${itemsHtml || '<span style="color: var(--text-secondary); font-style: italic;">No items</span>'}</td>
            <td class="visit-budtender" style="text-align: right; vertical-align: top; padding-top: 12px;">${budtender}</td>
          </tr>
        `;
      }).join('');

      document.getElementById('visitsContent').innerHTML = visitsHtml || '<tr><td colspan="3" class="data-label">No visits</td></tr>';
    }

    function startSync() {
      isPaused = false;
      fetchQueue();
      if (syncTimer) clearInterval(syncTimer);
      syncTimer = setInterval(fetchQueue, 15000); // Refresh every 15 seconds
    }

    function stopSync() {
      isPaused = true;
      if (syncTimer) clearInterval(syncTimer);
      updateStatus('Stopped');
    }

    // --- UPDATE SYSTEM ---
    // ALWAYS pulls latest version from GitHub (mota_desk_locked.dat)
    // Works with launcher - launcher will download and decrypt automatically
    const GITHUB_PAYLOAD_URL = "https://raw.githubusercontent.com/mmamodelai/projectMR/main/mota_desk_locked.dat";
    const APP_LOAD_TIME = new Date();
    let currentETag = null;
    let lastCheckTime = null;

    function triggerUpdate() {
      if(confirm("Update System?\n\nThis will reload and fetch the latest MotaDesk version from GitHub.\n\nIf using the Launcher, it will automatically decrypt with your saved password.")) {
        // Clear any cached data to force fresh download
        if (sessionStorage.getItem('mota_session_key')) {
          // Keep password in sessionStorage for launcher auto-reload
          console.log("Password saved in session - launcher will auto-reload");
        }
        // Force reload - launcher will handle download/decryption
        window.location.reload(true);
      }
    }

    async function checkForUpdates() {
        try {
            // Always check for updates - fetch HEAD with cache buster
            const response = await fetch(GITHUB_PAYLOAD_URL + "?t=" + Date.now() + "&r=" + Math.random(), { 
              method: 'HEAD', 
              cache: "no-store",
              headers: {
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'Pragma': 'no-cache'
              }
            });
            
            const newETag = response.headers.get('ETag') || response.headers.get('Last-Modified');
            const lastModified = response.headers.get('Last-Modified');
            
            if (newETag) {
                if (!currentETag) {
                    // First check - store current version
                    currentETag = newETag;
                    lastCheckTime = lastModified ? new Date(lastModified) : new Date();
                    console.log("Current system version:", currentETag);
                } else if (newETag !== currentETag) {
                    // New version detected!
                    console.log("New version available!", newETag);
                    const btn = document.getElementById('updateBtn');
                    if (btn) {
                        btn.classList.add('pulse-red');
                        btn.innerHTML = "‚¨á Update Available";
                        btn.title = "New version detected! Click to update.";
                    }
                }
            } else if (lastModified) {
                // Fallback to Last-Modified if no ETag
                const serverTime = new Date(lastModified);
                if (!lastCheckTime || serverTime > lastCheckTime) {
                    const btn = document.getElementById('updateBtn');
                    if (btn && serverTime > new Date(APP_LOAD_TIME.getTime() + 120000)) {
                        btn.classList.add('pulse-red');
                        btn.innerHTML = "‚¨á Update Available";
                        btn.title = "New version detected! Click to update.";
                    }
                    lastCheckTime = serverTime;
                }
            }
        } catch (e) {
            console.warn("Update check failed:", e);
        }
    }
    
    // Check every 5 minutes (faster updates)
    setInterval(checkForUpdates, 5 * 60 * 1000);
    // Initial check after 5 seconds
    setTimeout(checkForUpdates, 5000);

    // Load active budtenders for the dropdown
    async function fetchActiveBudtenders() {
      try {
        // Priority list requested by user
        const priorityNames = [
          "Grace", "50", "Cherish", "Jimmy", "Leo", 
          "Jacob", "John", "Lizbeth", "Joaq", "Luis", 
          "Agustin", "Devon"
        ];
        
        // Map for DB names (if different from display)
        // If user selects "Grace", we store "Grace" in the message content
        // but in the payload, we might want the real DB name if possible?
        // For now, user just said "attached to her DB table".
        // I'll just display the priority list.
        
        const options = [];
        
        // Add Priority (Display Name)
        priorityNames.forEach(name => {
           options.push(`<option value="${name}">${name}</option>`);
        });
        
        // Add "Other" option
        options.push('<option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>');
        options.push('<option value="Other">Other (Type Name)...</option>');
        
        const select = document.getElementById('modalBudtenderSelect');
        select.innerHTML = options.join('');
        select.value = "Grace"; // Default
        
      } catch (e) {
        console.error("Error fetching budtenders:", e);
      }
    }

    // --- VIEW SWITCHING ---
    function switchView(view) {
      currentView = view;
      
      // Update tab buttons
      document.getElementById('tabDashboard').classList.toggle('active', view === 'dashboard');
      document.getElementById('tabMessages').classList.toggle('active', view === 'messages');
      
      // STRICT VIEW ISOLATION
      const dashboardView = document.getElementById('viewDashboard');
      const messagesView = document.getElementById('viewMessages');
      
      if (view === 'dashboard') {
        dashboardView.classList.add('active');
        dashboardView.style.display = 'flex';
        messagesView.classList.remove('active');
        messagesView.style.display = 'none';
      } else if (view === 'messages') {
        dashboardView.classList.remove('active');
        dashboardView.style.display = 'none';
        messagesView.classList.add('active');
        messagesView.style.display = 'flex';
        loadAllMessages();
        if (currentConversationPhone && currentConversationPhoneKey) {
          loadConversation(currentConversationPhone, currentConversationPhoneKey);
        }
      }
    }
    
    // --- PINNING FUNCTIONALITY ---
    function togglePin(customerId) {
      const index = pinnedCustomers.indexOf(customerId);
      if (index > -1) {
        pinnedCustomers.splice(index, 1);
      } else {
        pinnedCustomers.push(customerId);
        // Resolve phone number immediately when pinning
        resolvePhoneForPinned(customerId);
      }
      renderQueue();
      localStorage.setItem('mota_pinned_customers', JSON.stringify(pinnedCustomers));
    }
    
    async function resolvePhoneForPinned(customerId) {
      try {
        await ensureSupabase();
        const { data: signup } = await supabase
          .from('phone_signups')
          .select('phone')
          .eq('member_id', customerId)
          .order('signup_timestamp', { ascending: false })
          .limit(1)
          .maybeSingle();
        
        if (signup && signup.phone) {
          const qItem = queue.find(q => q.customer_id === customerId);
          if (qItem) qItem.phone = signup.phone;
        }
      } catch (e) {
        console.warn('Error resolving phone for pinned:', e);
      }
    }
    
    function loadPinnedCustomers() {
      try {
        const saved = localStorage.getItem('mota_pinned_customers');
        if (saved) pinnedCustomers = JSON.parse(saved);
      } catch (e) {
        console.warn('Failed to load pinned:', e);
      }
    }
    
    async function pinConversationCustomer() {
      if (!currentConversationPhoneKey) {
        alert('No phone number available. Cannot pin.');
        return;
      }
      
      // Try to find customer by phone number
      let customerId = currentConversationCustomerId;
      
      if (!customerId) {
        try {
          await ensureSupabase();
          const customerMap = await batchLookupCustomers([currentConversationPhoneKey]);
          const customer = customerMap.get(currentConversationPhoneKey);
          if (customer) {
            customerId = customer.member_id || customer.id;
            currentConversationCustomerId = customerId;
          }
        } catch (e) {
          console.warn('Error looking up customer for pinning:', e);
        }
      }
      
      // If still no customer ID, try to find by phone in queue
      if (!customerId && currentConversationPhoneKey) {
        const queueCustomer = queue.find(q => {
          const qPhone = normalizePhone(q.phone || '');
          return qPhone.slice(-10) === currentConversationPhoneKey.slice(-10);
        });
        if (queueCustomer) {
          customerId = queueCustomer.customer_id;
          currentConversationCustomerId = customerId;
        }
      }
      
      // If we have a customer ID, pin it normally
      if (customerId) {
        togglePin(customerId);
        switchView('dashboard');
        if (selectCustomer) {
          selectCustomer(customerId);
        } else {
          // If customer not in queue, just switch to dashboard
          renderQueue();
        }
      } else {
        // No customer ID found - pin by phone number as fallback
        // Store phone-based pins separately
        const phonePins = JSON.parse(localStorage.getItem('mota_pinned_phones') || '[]');
        if (!phonePins.includes(currentConversationPhoneKey)) {
          phonePins.push(currentConversationPhoneKey);
          localStorage.setItem('mota_pinned_phones', JSON.stringify(phonePins));
          alert(`Phone number ${currentConversationPhoneKey} pinned. Will appear when customer is in queue.`);
        } else {
          phonePins.splice(phonePins.indexOf(currentConversationPhoneKey), 1);
          localStorage.setItem('mota_pinned_phones', JSON.stringify(phonePins));
          alert(`Phone number ${currentConversationPhoneKey} unpinned.`);
        }
        switchView('dashboard');
        renderQueue();
      }
    }
    
    // --- PHONE NUMBER NORMALIZATION ---
    function normalizePhone(phone) {
      if (!phone) return '';
      const digits = phone.replace(/\D/g, '');
      return digits.length >= 10 ? digits.slice(-10) : digits;
    }
    
    // --- ALL MESSAGES LOADING ---
    async function loadAllMessages() {
      const tbody = document.getElementById('allMessagesList');
      if (!tbody) return;
      tbody.innerHTML = '<tr><td colspan="5" style="padding: 40px; text-align: center; color: var(--text-secondary);">Loading messages...</td></tr>';
      
      try {
        await ensureSupabase();
        
        // Query inbound separately to ensure we get ALL inbound messages
        // Get ALL inbound regardless of status (read, unread, sent, delivered, etc.)
        // ONLY exclude SUG (suggested messages, not real SMS)
        const { data: inboundMessages } = await supabase
          .from('messages')
          .select('id, phone_number, content, direction, status, timestamp, payload')
          .eq('direction', 'inbound')
          .neq('status', 'SUG') // Only exclude suggested messages
          .order('timestamp', { ascending: false })
          .limit(2000); // Large limit to ensure we get all inbound
        
        // Query outbound (excluding unwanted statuses and internal logs)
        let outboundQuery = supabase
          .from('messages')
          .select('id, phone_number, content, direction, status, timestamp, payload')
          .eq('direction', 'outbound')
          .neq('status', 'SUG')
          .neq('status', 'APR')
          .neq('status', 'scheduled')
          .neq('status', 'queued')
          .neq('status', 'log') // Exclude log entries
          .neq('direction', 'internal'); // Exclude internal messages
        
        const { data: outboundMessages } = await outboundQuery
          .order('timestamp', { ascending: false })
          .limit(500);
        
        const allMessages = [
          ...(inboundMessages || []),
          ...(outboundMessages || [])
        ];
        
        // Sort by timestamp ONLY
        const sorted = allMessages.sort((a, b) => {
          return new Date(b.timestamp || 0) - new Date(a.timestamp || 0);
        });
        
        const messages = sorted.slice(0, 100);
        
        if (!messages || messages.length === 0) {
          tbody.innerHTML = '<tr><td colspan="5" style="padding: 40px; text-align: center; color: var(--text-secondary);">No messages found</td></tr>';
          return;
        }
        
        // Batch lookup customers
        const phoneNumbers = [...new Set(messages.map(m => {
          const normalized = normalizePhone(m.phone_number || '');
          return normalized.length >= 10 ? normalized.slice(-10) : normalized;
        }).filter(p => p.length >= 10))];
        
        const customerMap = await batchLookupCustomers(phoneNumbers);
        
        // Render
        tbody.innerHTML = messages.map(msg => {
          const rawPhone = msg.phone_number || 'Unknown';
          const normalizedPhone = normalizePhone(rawPhone);
          const phoneKey = normalizedPhone.length >= 10 ? normalizedPhone.slice(-10) : normalizedPhone;
          const displayPhone = phoneKey.length === 10 
            ? `(${phoneKey.slice(0,3)}) ${phoneKey.slice(3,6)}-${phoneKey.slice(6)}`
            : rawPhone;
          
          const customer = customerMap.get(phoneKey);
          const customerName = customer ? (customer.name || `${customer.first_name || ''} ${customer.last_name || ''}`.trim()) : null;
          
          const time = new Date(msg.timestamp || new Date()).toLocaleString('en-US', {
            month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'
          });
          
          const direction = msg.direction === 'inbound' ? 'üì• In' : 'üì§ Out';
          const statusDisplay = (msg.status || 'unknown').toUpperCase();
          
          let content = msg.content || '';
          if (content.match(/^[0-9A-Fa-f]+$/)) {
            try {
              content = decodeHexUCS2(content);
            } catch (e) {
              content = msg.content || '';
            }
          }
          if (content.length > 60) content = content.substring(0, 57) + '...';
          
          return `
            <tr onclick="loadConversation('${rawPhone}', '${phoneKey}')">
              <td style="padding: 12px 16px; color: var(--text-secondary); font-size: 11px;">${time}</td>
              <td style="padding: 12px 16px; color: ${msg.direction === 'inbound' ? '#10b981' : '#3b82f6'}; font-weight: 600;">${direction}</td>
              <td style="padding: 12px 16px;">
                ${customerName ? `<strong>${customerName}</strong><br><span style="color: var(--text-secondary); font-size: 11px;">${displayPhone}</span>` : displayPhone}
              </td>
              <td style="padding: 12px 16px; color: var(--text-secondary); font-size: 11px;">${statusDisplay}</td>
              <td style="padding: 12px 16px;">${content}</td>
            </tr>
          `;
        }).join('');
        
      } catch (error) {
        console.error('Error loading messages:', error);
        tbody.innerHTML = '<tr><td colspan="5" style="padding: 40px; text-align: center; color: var(--danger);">Error loading messages</td></tr>';
      }
    }
    
    // --- CONVERSATION FUNCTIONS ---
    async function loadConversation(phone, phoneKey) {
      currentConversationPhone = phone;
      currentConversationPhoneKey = phoneKey;
      
      const container = document.getElementById('conversationView');
      const header = document.getElementById('conversationHeader');
      
      container.innerHTML = '<div class="muted" style="text-align: center; padding: 20px;">Loading conversation...</div>';
      
      try {
        await ensureSupabase();
        
        // Get phone variants for flexible matching
        const variants = getPhoneVariants(phone);
        
        // Build OR query for all variants - get ALL messages for this phone
        // Exclude only internal/log messages, but include all real SMS (inbound and outbound)
        let query = supabase.from('messages').select('*');
        query = query.or(variants.map(v => `phone_number.ilike.%${v}%`).join(','));
        // Exclude internal log messages but include all real SMS
        query = query.neq('direction', 'internal');
        query = query.neq('status', 'log');
        query = query.order('timestamp', { ascending: true });
        
        const { data: messages } = await query;
        
        if (!messages || messages.length === 0) {
          container.innerHTML = '<div class="muted" style="text-align: center; padding: 40px;">No messages found</div>';
          return;
        }
        
        // Find customer - use more robust lookup
        const customerMap = await batchLookupCustomers([phoneKey]);
        const customer = customerMap.get(phoneKey);
        
        if (customer) {
          currentConversationCustomerId = customer.member_id || customer.id;
          const customerName = customer.name || 
                              (customer.first_name && customer.last_name ? `${customer.first_name} ${customer.last_name}`.trim() : null) ||
                              customer.first_name ||
                              'Unknown';
          header.textContent = `üí¨ ${customerName} (${phoneKey})`;
          
          // Update pin button
          const pinBtn = document.getElementById('conversationPinBtn');
          if (pinBtn) {
            const isPinned = pinnedCustomers.includes(currentConversationCustomerId);
            pinBtn.style.opacity = isPinned ? '1' : '0.3';
            pinBtn.textContent = isPinned ? 'üìå Pinned' : 'üìå Pin';
          }
        } else {
          // Try one more time with the raw phone
          const rawPhoneNormalized = normalizePhone(phone).slice(-10);
          const customer2 = customerMap.get(rawPhoneNormalized);
          if (customer2) {
            currentConversationCustomerId = customer2.member_id || customer2.id;
            const customerName = customer2.name || 
                                (customer2.first_name && customer2.last_name ? `${customer2.first_name} ${customer2.last_name}`.trim() : null) ||
                                customer2.first_name ||
                                'Unknown';
            header.textContent = `üí¨ ${customerName} (${phoneKey})`;
          } else {
            header.textContent = `üí¨ ${phoneKey}`;
            // Still allow pinning by phone
            const pinBtn = document.getElementById('conversationPinBtn');
            if (pinBtn) {
              pinBtn.style.opacity = '0.5';
              pinBtn.textContent = 'üìå Pin (by phone)';
            }
          }
        }
        
        // Render messages
        container.innerHTML = messages.map(m => {
          const isInbound = m.direction === 'inbound';
          let content = m.content || '';
          if (content.match(/^[0-9A-Fa-f]+$/)) {
            try {
              content = decodeHexUCS2(content);
            } catch (e) {}
          }
          
          const time = new Date(m.timestamp || new Date()).toLocaleString('en-US', {
            month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit'
          });
          
          return `
            <div class="message-bubble ${isInbound ? 'inbound' : 'outbound'}">
              <div>${content}</div>
              <div class="message-time">${time} ‚Ä¢ ${(m.status || 'unknown').toUpperCase()}</div>
            </div>
          `;
        }).join('');
        
        container.scrollTop = container.scrollHeight;
        
      } catch (error) {
        console.error('Error loading conversation:', error);
        container.innerHTML = '<div class="muted" style="text-align: center; padding: 40px; color: var(--danger);">Error loading conversation</div>';
      }
    }
    
    function getPhoneVariants(phone) {
      const normalized = normalizePhone(phone);
      return [
        normalized,
        `+1${normalized}`,
        `1${normalized}`,
        `+${normalized}`,
        phone
      ].filter((v, i, arr) => arr.indexOf(v) === i);
    }
    
    async function sendConversationReply() {
      const text = document.getElementById('conversationReplyText').value.trim();
      if (!text || !currentConversationPhone) return;
      
      try {
        await ensureSupabase();
        const { error } = await supabase.from('messages').insert({
          phone_number: currentConversationPhone,
          content: text,
          direction: 'outbound',
          status: 'queued',
          timestamp: new Date().toISOString()
        });
        
        if (error) throw error;
        
        document.getElementById('conversationReplyText').value = '';
        loadConversation(currentConversationPhone, currentConversationPhoneKey);
        loadAllMessages();
      } catch (error) {
        console.error('Error sending reply:', error);
        alert('Failed to send: ' + error.message);
      }
    }
    
    async function batchLookupCustomers(phoneNumbers) {
      const customerMap = new Map();
      if (!phoneNumbers || phoneNumbers.length === 0) return customerMap;
      
      try {
        await ensureSupabase();
        
        // Normalize all phone numbers to last 10 digits for matching
        const normalizedPhones = phoneNumbers.map(p => {
          const normalized = normalizePhone(p);
          return normalized.length >= 10 ? normalized.slice(-10) : normalized;
        }).filter(p => p.length >= 10);
        
        if (normalizedPhones.length === 0) return customerMap;
        
        // Strategy 1: Check phone_signups by phone (not phone_normalized column)
        for (const phone of normalizedPhones) {
          try {
            const { data: signups } = await supabase
              .from('phone_signups')
              .select('member_id, phone, customer_name, first_name, last_name')
              .or(`phone.ilike.%${phone}%,phone.ilike.%+1${phone}%,phone.ilike.%1${phone}%`)
              .limit(1);
            
            if (signups && signups.length > 0) {
              const s = signups[0];
              const key = normalizePhone(s.phone).slice(-10);
              if (key && !customerMap.has(key)) {
                customerMap.set(key, {
                  member_id: s.member_id,
                  id: s.member_id,
                  name: s.customer_name || `${s.first_name || ''} ${s.last_name || ''}`.trim(),
                  first_name: s.first_name,
                  last_name: s.last_name
                });
              }
            }
          } catch (e) {
            console.warn('Error checking phone_signups:', e);
          }
        }
        
        // Strategy 2: Check customers_blaze with flexible matching
        for (const phone of normalizedPhones) {
          if (customerMap.has(phone)) continue; // Already found
          
          try {
            const { data: customers } = await supabase
              .from('customers_blaze')
              .select('member_id, id, phone, phone_number, name, first_name, last_name')
              .or(`phone.ilike.%${phone}%,phone_number.ilike.%${phone}%,phone.ilike.%+1${phone}%,phone_number.ilike.%+1${phone}%`)
              .limit(1);
            
            if (customers && customers.length > 0) {
              const c = customers[0];
              const phoneValue = c.phone || c.phone_number;
              const key = normalizePhone(phoneValue).slice(-10);
              if (key && !customerMap.has(key)) {
                customerMap.set(key, {
                  member_id: c.member_id,
                  id: c.id || c.member_id,
                  name: c.name || `${c.first_name || ''} ${c.last_name || ''}`.trim(),
                  first_name: c.first_name,
                  last_name: c.last_name
                });
              }
            }
          } catch (e) {
            console.warn('Error checking customers_blaze:', e);
          }
        }
        
        // Strategy 3: Also check customers table
        for (const phone of normalizedPhones) {
          if (customerMap.has(phone)) continue; // Already found
          
          try {
            const { data: customers } = await supabase
              .from('customers')
              .select('id, member_id, phone, name, first_name, last_name')
              .or(`phone.ilike.%${phone}%,phone.ilike.%+1${phone}%`)
              .limit(1);
            
            if (customers && customers.length > 0) {
              const c = customers[0];
              const key = normalizePhone(c.phone).slice(-10);
              if (key && !customerMap.has(key)) {
                customerMap.set(key, {
                  member_id: c.member_id,
                  id: c.id,
                  name: c.name || `${c.first_name || ''} ${c.last_name || ''}`.trim(),
                  first_name: c.first_name,
                  last_name: c.last_name
                });
              }
            }
          } catch (e) {
            console.warn('Error checking customers:', e);
          }
        }
      } catch (e) {
        console.warn('Error in batch lookup:', e);
      }
      
      return customerMap;
    }
    
    function decodeHexUCS2(hex) {
      // Hex to UCS2 decoder (handles emojis with surrogate pairs)
      const bytes = [];
      for (let i = 0; i < hex.length; i += 2) {
        bytes.push(parseInt(hex.substr(i, 2), 16));
      }
      let result = '';
      for (let i = 0; i < bytes.length; i += 2) {
        const codePoint = (bytes[i] << 8) | bytes[i + 1];
        if (codePoint >= 0xD800 && codePoint <= 0xDBFF && i + 2 < bytes.length) {
          const high = codePoint;
          const low = (bytes[i + 2] << 8) | bytes[i + 3];
          if (low >= 0xDC00 && low <= 0xDFFF) {
            const surrogate = 0x10000 + ((high - 0xD800) << 10) + (low - 0xDC00);
            result += String.fromCodePoint(surrogate);
            i += 2;
          } else {
            result += String.fromCharCode(codePoint);
          }
        } else {
          result += String.fromCharCode(codePoint);
        }
      }
      return result;
    }
    
    async function ensureSupabase() {
      if (!supabase) {
        await initSupabase();
      }
      return supabase;
    }

    window.addEventListener('DOMContentLoaded', async () => {
      await initSupabase();
      loadColumnWidths();
      loadPinnedCustomers(); // Load pinned customers
      fetchActiveBudtenders(); // Load dropdown options
      startSync();
      
      // Subscribe to chat on page load (for pulse notifications)
      subscribeToChat();
      
      // Character count for conversation reply
      const replyText = document.getElementById('conversationReplyText');
      const charCount = document.getElementById('conversationCharCount');
      if (replyText && charCount) {
        replyText.addEventListener('input', () => {
          const len = replyText.value.length;
          charCount.textContent = `${len} / 160`;
        });
      }
      
      // Update checking is handled by the main checkForUpdates function above
    });
  </script>
</body>
</html>
